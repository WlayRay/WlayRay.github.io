<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>go语言实现雪花算法+生产者消费者模型</title>
      <link href="/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
      <url>/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>由Twitter提出，用于在分布式环境下生成唯一且有序的64位整型ID，并且可以确保递增性。我在实习中经常见到使用雪花算法作为数据库主键，在<a href="https://github.com/WlayRay/ElectricSearch">ElectricSearch</a>这个项目中则用作倒排索引中文档的ID。</p><h3 id="算法原理与实现"><a href="#算法原理与实现" class="headerlink" title="算法原理与实现"></a>算法原理与实现</h3><p>雪花算法的各个组成部分：</p><table><thead><tr><th>符号位(1位)</th><th>时间戳(41位)</th><th>机器ID(10位)</th><th>序列号(12位)</th></tr></thead></table><ol><li>时间戳部分：占用了41位，用来记录生成ID的时间，单位为毫秒。时间戳部分可以支持大约68年的时间跨度（从算法开始的时间点算起）。</li><li>机器标识部分：占用了10位，可以用来标识不同的机器。这意味着可以支持最多2^10 &#x3D; 1024台机器。每台机器在这个集群中都有一个唯一的标识号。</li><li>序列号部分：占用了12位，用来在同一个毫秒内生成多个ID。每个机器每毫秒内可以生成2^12 &#x3D; 4096个不同的ID。</li><li>标志位：占用了1位，通常设为0，不使用。</li></ol><p>生成唯一ID的过程：</p><ol><li>获取当前的时间戳（毫秒级）。</li><li>将当前时间戳减去某个固定的时间基点（可以为编写算法时的时间点），得到相对于起始时间的时间差。</li><li>将时间差左移42位（即41位时间戳 + 1位不用的标志位）。</li><li>将机器ID左移12位（即序列号占用的位数）。</li><li>将上述两个结果相加。</li><li>加上当前毫秒内的序列号。</li></ol><p>代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    workerBits  <span class="type">uint8</span>  = <span class="number">10</span>                      <span class="comment">// 每台机器(节点)的ID位数 10位最大可以有2^10=1024个节点</span></span><br><span class="line">    numberBits  <span class="type">uint8</span>  = <span class="number">12</span>                      <span class="comment">// 表示每个集群下的每个节点，1毫秒内可生成的id序号的二进制位数 即每毫秒可生成 2^12-1=4096个唯一ID</span></span><br><span class="line">    workerMax   <span class="type">uint64</span> = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; workerBits) <span class="comment">// 节点ID的最大值，用于防止溢出</span></span><br><span class="line">    numberMax   <span class="type">uint64</span> = <span class="number">-1</span> ^ (<span class="number">-1</span> &lt;&lt; numberBits) <span class="comment">// 同上，用来表示生成id序号的最大值</span></span><br><span class="line">    timeShift   <span class="type">uint8</span>  = workerBits + numberBits <span class="comment">// 时间戳向左的偏移量</span></span><br><span class="line">    workerShift <span class="type">uint8</span>  = numberBits              <span class="comment">// 节点ID向左的偏移量</span></span><br><span class="line">    <span class="comment">// 41位字节作为时间戳数值的话 大约68年就会用完</span></span><br><span class="line">    <span class="comment">// 假如你2010年1月1日开始开发系统 如果不减去2010年1月1日的时间戳 那么白白浪费40年的时间戳啊！</span></span><br><span class="line">    <span class="comment">// 这个一旦定义且开始生成ID后千万不要改了 不然可能会生成相同的ID</span></span><br><span class="line">    epoch <span class="type">uint64</span> = <span class="number">1724896773911</span> <span class="comment">// 在写这个变量时的时间戳</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu        sync.Mutex</span><br><span class="line">    timestamp <span class="type">uint64</span></span><br><span class="line">    workerId  <span class="type">uint64</span></span><br><span class="line">    number    <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(workerId <span class="type">uint64</span>)</span></span> (*Worker, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> workerId &gt; workerMax &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Worker ID excess of quantity&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;Worker&#123;</span><br><span class="line">        timestamp: <span class="number">0</span>,</span><br><span class="line">        workerId:  workerId,</span><br><span class="line">        number:    <span class="number">0</span>,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> GetId() <span class="type">uint64</span> &#123;</span><br><span class="line">    w.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> w.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取生成时的时间戳</span></span><br><span class="line">    now := <span class="type">uint64</span>(time.Now().UnixNano() / <span class="number">1e6</span>) <span class="comment">// 纳秒转毫秒</span></span><br><span class="line">    <span class="keyword">if</span> w.timestamp == now &#123;</span><br><span class="line">        w.number++</span><br><span class="line">        <span class="comment">// 如果当前工作节点在1毫秒内生成的ID已经超过上限 需要等待1毫秒再继续生成</span></span><br><span class="line">        <span class="keyword">if</span> w.number &gt; numberMax &#123;</span><br><span class="line">            <span class="keyword">for</span> now &lt;= w.timestamp &#123;</span><br><span class="line">                now = <span class="type">uint64</span>(time.Now().UnixNano() / <span class="number">1e6</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前时间与工作节点上一次生成ID的时间不一致 则需要重置工作节点生成ID的序号</span></span><br><span class="line">        w.number = <span class="number">0</span></span><br><span class="line">        w.timestamp = now <span class="comment">// 将机器上一次生成ID的时间更新为当前时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一段 now - epoch 为该算法目前已经运行了xxx毫秒</span></span><br><span class="line">    <span class="comment">// 如果在程序跑了一段时间修改了epoch这个值 可能会导致生成相同的ID</span></span><br><span class="line">    ID := <span class="type">uint64</span>((now-epoch)&lt;&lt;timeShift | (w.workerId &lt;&lt; workerShift) | (w.number))</span><br><span class="line">    <span class="keyword">return</span> ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h3 id="算法的测试与生产者消费者模型"><a href="#算法的测试与生产者消费者模型" class="headerlink" title="算法的测试与生产者消费者模型"></a>算法的测试与生产者消费者模型</h3><p>由于雪花算法适用于分布式系统，一般用到的场景都会有不小的并发，这里我使用生产者消费者模式来测试雪花算法。</p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">workerIds := []<span class="type">uint64</span>&#123;<span class="number">123</span>, <span class="number">456</span>&#125;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    p = <span class="number">10</span>     <span class="comment">//生产者数量</span></span><br><span class="line">    c = <span class="number">12</span>     <span class="comment">//消费者数量</span></span><br><span class="line">    n = <span class="number">120000</span> <span class="comment">//生成ID总数</span></span><br><span class="line">    )</span><br><span class="line"><span class="comment">//创建两个worker节点，模拟两台机器</span></span><br><span class="line">worker1, _ := util.NewWorker(workerIds[<span class="number">0</span>])</span><br><span class="line">worker2, _ := util.NewWorker(workerIds[<span class="number">1</span>])</span><br><span class="line">ids := sync.Map&#123;&#125; <span class="comment">//用于判重的集合，键为雪花算法生成的ID，值为空结构体</span></span><br><span class="line"></span><br><span class="line">repetitions, count := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">uint64</span>, n/p) <span class="comment">//用于接收生产者生成的ID</span></span><br><span class="line">pwg := sync.WaitGroup&#123;&#125;</span><br><span class="line">cwg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">cwg.Add(c)</span><br><span class="line">pwg.Add(p)</span><br><span class="line"></span><br><span class="line">start := time.Now()      <span class="comment">//记录生成ID的开始时间</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p; i++ &#123; <span class="comment">//开启p个生产者并发生成ID发送至results</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> pwg.Done()</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n/p+<span class="number">4</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">                results &lt;- worker1.GetId()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                results &lt;- worker2.GetId()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; c; i++ &#123; <span class="comment">//开启c个消费者并发读取results并对ID进行判重</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> cwg.Done()</span><br><span class="line">        <span class="keyword">for</span> id := <span class="keyword">range</span> results &#123;</span><br><span class="line">            <span class="comment">// 如果ID已存在于ids集合中，则说明重复</span></span><br><span class="line">            <span class="keyword">if</span> _, loaded := ids.LoadOrStore(id, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;); loaded &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;id: %d 重复！\n&quot;</span>, id)</span><br><span class="line">                repetitions++</span><br><span class="line">                count++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwg.Wait()</span><br><span class="line">end := time.Now() <span class="comment">//记录生成ID的结束时间</span></span><br><span class="line"><span class="built_in">close</span>(results)</span><br><span class="line">cwg.Wait()</span><br><span class="line"></span><br><span class="line">duration := end.Sub(start)</span><br><span class="line">fmt.Printf(<span class="string">&quot;生成的ID总数：%d，重复的ID共：%d个，重复率为：%.4f\n&quot;</span>, count, repetitions, <span class="type">float64</span>(repetitions)/<span class="type">float64</span>(count)*<span class="number">100</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;生成ID耗时: %d 毫秒\n&quot;</span>, duration.Milliseconds())</span><br></pre></td></tr></table></figure><p>测试结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: 2656171589087232 重复！</span><br><span class="line">id: 2656171593281536 重复！</span><br><span class="line">生成的ID总数：120023，重复的ID共：2个，重复率为：0.0017</span><br><span class="line">生成ID耗时: 79 毫秒</span><br></pre></td></tr></table></figure><p>可见雪花算法不仅效率高，并且在超高并发下也能保证极低的错误率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端算法（go语言实现） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言实现布隆过滤器</title>
      <link href="/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="概念与使用场景"><a href="#概念与使用场景" class="headerlink" title="概念与使用场景"></a>概念与使用场景</h3><p><strong>布隆过滤器</strong>（Bloom Filter）由Burton Howard Bloom在1970年提出的，用于测试一个元素是否在一个集合中。这种数据结构的特点是空间效率高且查询速度快，但有一定的误报率，并且不支持从集合中删除元素。最常见的使用场景为存储Redis的Key以防止缓存雪崩</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><strong>组成</strong>：<ul><li>一个很长的二进制向量（Bitmap，也称为位图）。</li><li>多个独立的哈希函数。</li></ul></li><li><strong>插入操作</strong>：<ul><li>当一个元素被添加到布隆过滤器时，多个哈希函数会被应用到这个元素上。</li><li>每个哈希函数会产生一个索引，指示位数组中的某个位置。</li><li>对应这些位置的比特位会被设置为1。</li></ul></li><li><strong>查询操作</strong>：<ul><li>查询一个元素是否存在时，同样使用相同的哈希函数来计算位数组中的位置。</li><li>如果所有这些位置上的比特位都是1，则认为该元素可能存在于集合中。</li><li>如果有任何一个位置的比特位是0，则确定该元素不在集合中。</li></ul></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>优点</strong>：<ul><li>极大地节省了存储空间。</li><li>查询速度非常快。</li></ul></li><li><strong>缺点</strong>：<ul><li>存在一定的误报率，即可能会错误地报告一个元素存在于集合中（假阳性）。</li><li>不支持从集合中删除元素。</li><li>误报率随着插入元素的数量增加而增加。</li></ul></li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>使用go语言实现要点</p><ul><li>创建一个布隆过滤器的结构体，包含位图、位图长度、哈希种子。可自行确定 hashNum（哈希函数的个数）和 bitCount（位图的长度）参数。</li><li>因为go语言最小的类型为byte，位图只能用 byte 切片表示，因此 byte 切片的长度为 bitCount &#x2F; 8。</li><li>进行插入和查询操作时，设经过一次哈希运算后得到的 Bitmap 下标为 index ，index &#x2F; 8 为 index 在byte切片中的位置，index % 8 为 index 在该位置中的偏移量。</li><li>哈希函数使用 github.com&#x2F;dgryski&#x2F;go-farm 库的 farm.Hash32WithSeed 函数。</li></ul><p>实现代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/dgryski/go-farm&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BloomFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">    BitMap   []<span class="type">byte</span></span><br><span class="line">    BitCount <span class="type">int</span></span><br><span class="line">    Seeds    []<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewBloomFilter</span></span><br><span class="line"><span class="comment">// hashNum为hash函数的个数,</span></span><br><span class="line"><span class="comment">// bitCount为bitmap的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBloomFilter</span><span class="params">(hashNum, bitCount <span class="type">int</span>)</span></span> *BloomFilter &#123;</span><br><span class="line">    size := bitCount / <span class="number">8</span></span><br><span class="line">    seeds := <span class="built_in">make</span>([]<span class="type">uint32</span>, hashNum)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; hashNum; i++ &#123;</span><br><span class="line">        seeds[i] = <span class="type">uint32</span>(rand.Int())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;BloomFilter&#123;</span><br><span class="line">        BitMap:   <span class="built_in">make</span>([]<span class="type">byte</span>, size),</span><br><span class="line">        BitCount: bitCount,</span><br><span class="line">        Seeds:    seeds,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf *BloomFilter)</span></span> getBit(index <span class="type">uint32</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    a := index / <span class="number">8</span></span><br><span class="line">    v := <span class="type">uint</span>(bf.BitMap[a])</span><br><span class="line">    b := <span class="type">uint</span>(<span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">return</span> v&amp;b == b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf *BloomFilter)</span></span> setBit(index <span class="type">uint32</span>) &#123;</span><br><span class="line">    bf.BitMap[index/<span class="number">8</span>] |= <span class="number">1</span> &lt;&lt; (index % <span class="number">8</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf *BloomFilter)</span></span> Add(elem <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, seed := <span class="keyword">range</span> bf.Seeds &#123;</span><br><span class="line">        index := farm.Hash32WithSeed([]<span class="type">byte</span>(elem), seed) % <span class="type">uint32</span>(bf.BitCount)</span><br><span class="line">        bf.setBit(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf *BloomFilter)</span></span> Exists(elem <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, seed := <span class="keyword">range</span> bf.Seeds &#123;</span><br><span class="line">  index := farm.Hash32WithSeed([]<span class="type">byte</span>(elem), seed) % <span class="type">uint32</span>(bf.BitCount)</span><br><span class="line">        <span class="comment">//fmt.Println(index)</span></span><br><span class="line">        <span class="keyword">if</span> !bf.getBit(index) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把布隆过滤器导出到文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf *BloomFilter)</span></span> Export(file <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    fout, err := os.OpenFile(file, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, <span class="number">0o666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fout.Close()</span><br><span class="line">    writer := bufio.NewWriter(fout)</span><br><span class="line">    <span class="keyword">defer</span> writer.Flush()</span><br><span class="line">    encoder := gob.NewEncoder(writer)</span><br><span class="line">    <span class="keyword">return</span> encoder.Encode(*bf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadBloomFilter</span><span class="params">(file <span class="type">string</span>)</span></span> (*BloomFilter, <span class="type">error</span>) &#123;</span><br><span class="line">    fin, err := os.Open(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fin.Close()</span><br><span class="line">    reader := bufio.NewReader(fin)</span><br><span class="line">    decoder := gob.NewDecoder(reader)</span><br><span class="line">    <span class="keyword">var</span> bf BloomFilter</span><br><span class="line">    err = decoder.Decode(&amp;bf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;bf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 后端算法（go语言实现） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面试题之手写线程池</title>
      <link href="/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><ul><li>任务队列：使用 std::function 来包装任务，通过完美转发传递参数实现类型保留</li><li>线程管理：初始化一组工作线程循环获取任务，当线程池不再被需要时，安全停止所有线程</li><li>同步机制：使用互斥量保护任务队列，使用条件变量来通知工作线程有任务可执行或停止工作</li><li>结果返回：使用 std::packaged_task 来包装任务，使用 std::future 来获取任务结果</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; m_threads;</span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; m_tasks;</span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">    std::condition_variable m_condition;</span><br><span class="line">    <span class="type">uint16_t</span> m_threads_num;</span><br><span class="line">    <span class="type">bool</span> m_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> _threadNum) : <span class="built_in">m_threads_num</span>(_threadNum), <span class="built_in">m_stop</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread pool constructing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_threads_num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]()</span><br><span class="line">                                   &#123;</span><br><span class="line">                                    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(m_mutex);</span><br><span class="line">                                            m_condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> !m_tasks.<span class="built_in">empty</span>() || m_stop; &#125;);</span><br><span class="line">                                            <span class="keyword">if</span> (m_stop &amp;&amp; m_tasks.<span class="built_in">empty</span>())</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="keyword">return</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                            task = std::<span class="built_in">move</span>(m_tasks.<span class="built_in">front</span>());</span><br><span class="line">                                            m_tasks.<span class="built_in">pop</span>();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="built_in">task</span>();</span><br><span class="line">                                    &#125; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    std::future&lt;std::<span class="type">result_of_t</span>&lt;<span class="built_in">F</span>(Args...)&gt;&gt; <span class="built_in">addTask</span>(F &amp;&amp;_task, Args &amp;&amp;..._args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> return_type = std::<span class="type">result_of_t</span>&lt;<span class="built_in">F</span>(Args...)&gt;;</span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(_task), std::forward&lt;Args&gt;(_args)...));</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            m_tasks.<span class="built_in">emplace</span>([task]()</span><br><span class="line">                            &#123; (*task)(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        std::future&lt;return_type&gt; future = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            m_stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_condition.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : m_threads)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>())</span><br><span class="line">                thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread pool destructed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; calculating: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::array&lt;std::future&lt;<span class="type">int</span>&gt;, <span class="number">10</span>&gt; futures;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        futures[i] = pool.<span class="built_in">addTask</span>(calculate, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calculate result: &quot;</span> &lt;&lt; futures[i].<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面试题之手写unique_ptr</title>
      <link href="/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%89%8B%E5%86%99unique-ptr/"/>
      <url>/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%89%8B%E5%86%99unique-ptr/</url>
      
        <content type="html"><![CDATA[<h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><ul><li>每个 unique_ptr 都独占其所管理的对象，因此无法被复制，应当删除其拷贝构造函数和赋值运算符。</li><li>使用移动构造函数或移动赋值运算时，要将被移动的对象的底层指针置空。</li><li>重载解引用 * 和箭头 -&gt; 运算符，实现类似普通指针的调用</li><li>使用RAII机制自动释放资源</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniquePtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UniquePtr</span>(<span class="type">const</span> UniquePtr&lt;T&gt; &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    UniquePtr&lt;T&gt; <span class="keyword">operator</span>=(<span class="type">const</span> UniquePtr&lt;T&gt; &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UniquePtr</span><span class="params">(T *p = <span class="literal">nullptr</span>)</span> : ptr(p)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UniquePtr</span>(UniquePtr&lt;T&gt; &amp;&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = other.ptr;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UniquePtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(UniquePtr&lt;T&gt; &amp;&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr != other.ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *p = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T *p = ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(UniquePtr&lt;T&gt; &amp;other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(ptr, other.ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UniquePtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面试题之手写shared_ptr</title>
      <link href="/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%89%8B%E5%86%99shared-ptr/"/>
      <url>/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%89%8B%E5%86%99shared-ptr/</url>
      
        <content type="html"><![CDATA[<h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><ul><li>shared_ptr 的引用计数应当使用原子操作（std::atomic）确保最低限度的并发安全。</li><li>多个指向同一个底层指针对象的shared_ptr，它们的引用计数应当相等，因此应该将引用计数也定义成指针。</li><li>使用移动赋值运算时，被移动的shared_ptr的引用计数应当减1，同时要判断是否释放资源（引用计数为0时）。</li><li>使用移动构造函数时，要将被移动的对象的底层指针和引用计数器置空。</li><li>重载解引用 * 和箭头 -&gt; 运算符，实现类似普通指针的调用</li><li>使用RAII机制自动释放资源</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; *count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SharedPtr</span><span class="params">(T *p = <span class="literal">nullptr</span>)</span> : ptr(p), count(new std::atomic&lt;int&gt;(<span class="number">1</span>))</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count-&gt;<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr&lt;T&gt; &amp;other) : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">count</span>(other.count)</span><br><span class="line">    &#123;</span><br><span class="line">        count-&gt;<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SharedPtr</span>(SharedPtr&lt;T&gt; &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">count</span>(other.count)</span><br><span class="line">    &#123;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        other.count = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SharedPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SharedPtr&lt;T&gt; &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ptr != other.ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count-&gt;<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;ptr = other.ptr;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = other.count;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                count-&gt;<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SharedPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp;&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ptr != other.ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (count-&gt;<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;ptr = other.ptr;</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = other.count;</span><br><span class="line">            other.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            other.count = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SharedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count-&gt;<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count-&gt;<span class="built_in">load</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count-&gt;<span class="built_in">load</span>() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(SharedPtr&lt;T&gt; &amp;other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(ptr, other.ptr);</span><br><span class="line">        std::<span class="built_in">swap</span>(count, other.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *p = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ptr != p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*count).<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = p;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="keyword">new</span> std::<span class="built_in">atomic</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用jmeter压测TCP项目</title>
      <link href="/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/"/>
      <url>/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前置准备"><a href="#一、前置准备" class="headerlink" title="一、前置准备"></a>一、前置准备</h2><h3 id="1-下载jmeter"><a href="#1-下载jmeter" class="headerlink" title="1.下载jmeter"></a>1.下载jmeter</h3><p>首先需要有java环境，安装java环境在这里不做演示</p><p>jmeter官网下载链接：<a href="https://jmeter.apache.org/download_jmeter.cgi" download>Apache JMeter - Download Apache JMeter</a></p><p>下载下面的二进制压缩包<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/downloadjmeter.png"><br><br></p><h3 id="2-中文切换（可选）"><a href="#2-中文切换（可选）" class="headerlink" title="2. 中文切换（可选）"></a>2. 中文切换（可选）</h3><p>在解压后的bin（apache-jmeter-5.6.3\bin）目录里编辑jmeter.properties文件，找到#language&#x3D;en，将其取消注释并改成language&#x3D;zh_CN<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/setChinese.png"></p><h3 id="3-运行jmeter"><a href="#3-运行jmeter" class="headerlink" title="3.运行jmeter"></a>3.运行jmeter</h3><p>在bin目录里找到jmeter.bat文件，双击运行<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/runjmeter.png"><br>稍等一会后会出现jmeter的图形化界面<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/jmeterGUI.png"><br><br></p><h2 id="二、压测步骤"><a href="#二、压测步骤" class="headerlink" title="二、压测步骤"></a>二、压测步骤</h2><h3 id="1-创建线程组"><a href="#1-创建线程组" class="headerlink" title="1.创建线程组"></a>1.创建线程组</h3><p>右键测试计划，选择添加-&gt;线程（用户）-&gt;线程组<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/addThreadGroup.png"></p><p>这里我先创建1500个线程，设置启动延迟为10秒，并选择创建线程直到需要。<br><strong>解释：</strong> 线程数可以理解为并发数，启动延迟（Ramp-Up Period）可以理解为压测开始前的等待时间，当你在 JMeter 的线程组中设置了“Ramp-Up时间”时，JMeter 会在这个时间段内逐渐启动所有线程，而不是一次性启动所有线程。例如，我设置了线程数为 1500，启动延迟为 10 秒，那么 JMeter 将在这 60 秒内依次启动 1500 个线程，有助于测试服务器在逐步增加的负载下的表现。<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/threadGroup.png"></p><h3 id="2-添加TCP取样器"><a href="#2-添加TCP取样器" class="headerlink" title="2.添加TCP取样器"></a>2.添加TCP取样器</h3><p>右键刚刚的线程组，选择添加-&gt;取样器-&gt;TCP取样器<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/tcpSampler.png"></p><p>填入要压测服务的IP、端口等信息<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/samplerInfo.png"><br>注意图中红色方框，因为TCP是流是协议，应用程序需要根据一个特殊的标识来判断是否已经到所有数据，因此需要我们配置”行尾（EOF）字节值”，取值范围为 -128 到 +127，它用于定义 TCP 服务器响应数据的结束标识。当 jmeter 接收到来自服务器的数据时，它会根据这个 EOF 字节值来判断何时停止读取更多的数据。</p><p>比如果说我的请求和响应如下：<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E6%B5%8B%E8%AF%95%E8%AF%B7%E6%B1%82%E6%A0%B7%E4%BE%8B.png"><br>如果服务正常运行则会返回json文本：<br>{“errmsg”:”No such method, failed to process your request!”,”errno”:404,”msgType”:404}<br>表示找不到msgType为100的方法，该文本最后一个字符是是”}”，对应的编码转为10进制是125，因此在行位尾（EOF）字节值中填入125</p><p>如果不填入行尾（EOF）字节值，jmeter会一直等待，直到超时，或者直到服务器返回数据，导致压测失败。</p><p>可以看到即使返回了预期的json也仍然显示失败<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E6%B5%8B%E8%AF%95%E5%A4%B1%E8%B4%A5.png"></p><p>填入行位尾（EOF）字节值后，测试成功：<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F.png"></p><h3 id="3-添加监听器"><a href="#3-添加监听器" class="headerlink" title="3.添加监听器"></a>3.添加监听器</h3><p>右键TCP取样器，选择添加-&gt;监听器，可以添加多个不同功能的监听器<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/addListener.png"></p><p>点击上方的绿色启动按钮进行压测<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E5%90%AF%E5%8A%A8%E5%8E%8B%E6%B5%8B.png"></p><h2 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h2><p>压测的项目地址：<a href="https://github.com/WlayRay/RayBoxServer">https://github.com/WlayRay/RayBoxServer</a></p><p>走数据库的请求压测<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E8%B5%B0%E6%95%B0%E6%8D%AE%E5%BA%9310%E7%A7%92%E7%BC%93%E5%86%B29500%E5%B9%B6%E5%8F%91%E5%8E%8B%E6%B5%8B.png"><br>不走数据库<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E4%B8%8D%E8%B5%B0%E6%95%B0%E6%8D%AE%E5%BA%9310%E7%A7%92%E7%BC%93%E5%86%B216000%E5%B9%B6%E5%8F%91%E5%8E%8B%E6%B5%8B.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序、归并排序、堆排序对比</title>
      <link href="/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AF%B9%E6%AF%94%EF%BC%88go%E8%AF%AD%E8%A8%80%EF%BC%89/"/>
      <url>/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AF%B9%E6%AF%94%EF%BC%88go%E8%AF%AD%E8%A8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="在所有排序算法中，平均时间复杂度为O-nlogn-的算法一共有三种：快速排序、归并排序、堆排序。"><a href="#在所有排序算法中，平均时间复杂度为O-nlogn-的算法一共有三种：快速排序、归并排序、堆排序。" class="headerlink" title="在所有排序算法中，平均时间复杂度为O(nlogn)的算法一共有三种：快速排序、归并排序、堆排序。"></a>在所有排序算法中，平均时间复杂度为O(nlogn)的算法一共有三种：快速排序、归并排序、堆排序。</h3><table><thead><tr><th>排序算法</th><th align="center">最好情况时间复杂度</th><th align="center">平均情况时间复杂度</th><th align="center">最坏情况时间复杂度</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td>选择排序</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td>插入排序</td><td align="center">O(n)</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td>冒泡排序</td><td align="center">O(n)</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td>归并排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td>快速排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n²)</td><td align="center">O(log n)</td><td align="center">不稳定</td></tr><tr><td>堆排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td>希尔排序</td><td align="center">O(n)</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td>基数排序</td><td align="center">O(nk)</td><td align="center">O(nk)</td><td align="center">O(nk)</td><td align="center">O(n + d)</td><td align="center">稳定</td></tr></tbody></table><p>注：</p><ul><li><strong>稳定性</strong>：如果两个元素相等，排序后它们的相对顺序不变，则称该排序算法是稳定的。</li><li><strong>希尔排序的时间复杂度</strong>和增量选择有关，如果增量序列是1，2，4，8，16，32，64，128，256，512，1024，则时间复杂度为O(n)。</li><li><strong>基数排序的时间复杂度</strong>为O(nk)，其中k为元素的位数。<br></li></ul><h4 id="一、快速排序"><a href="#一、快速排序" class="headerlink" title="一、快速排序"></a>一、快速排序</h4><p>步骤详解：</p><ol><li>选择基准值<ul><li>选择基准值，一般选择第一个元素作为基准值。</li></ul></li><li>分区操作<ul><li>将数组分成两个部分，左边的元素都小于基准值，右边的元素都大于基准值。</li><li>常见的分区方法是使用两个指针，一个从左向右扫描，另一个从右向左扫描，当左侧的指针找到一个大于基准值的元素时停止，右侧的指针找到一个小于基准值的元素时停止，然后交换这两个元素的位置。</li><li>这个过程一直持续到两个指针相遇，这时将基准值与相遇位置的元素交换，这样基准值就位于正确的位置上。</li></ul></li><li>递归排序<ul><li>对基准值左边的子数组和基准值右边的子数组进行递归排序。</li></ul></li></ol><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">        mid := partition(arr, left, right)</span><br><span class="line">        QuickSort(arr, left, mid<span class="number">-1</span>)</span><br><span class="line">        QuickSort(arr, mid+<span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    pivot, l := arr[right], left<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := left; i &lt; right; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; pivot &#123;</span><br><span class="line">         l++</span><br><span class="line">            arr[l], arr[i] = arr[i], arr[l]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    l++</span><br><span class="line">    arr[l], arr[right] = arr[right], arr[l]</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="二、归并排序"><a href="#二、归并排序" class="headerlink" title="二、归并排序"></a>二、归并排序</h4><p>步骤详解：</p><ol><li>分割：如果数组长度大于1，则将数组分成两个子数组。</li><li>递归排序：递归地对两个子数组进行排序。</li><li>合并：将两个已排序的子数组合并成一个有序数组。</li></ol><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mid := <span class="built_in">len</span>(arr) / <span class="number">2</span></span><br><span class="line">    left := MergeSort(arr[:mid])</span><br><span class="line">    right := MergeSort(arr[mid:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, left[i])</span><br><span class="line">        i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, right[j])</span><br><span class="line">        j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当其中一个数组已经全部被添加到结果数组中，将另一个数组剩下的元素添加进来</span></span><br><span class="line">    result = <span class="built_in">append</span>(result, left[i:]...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, right[j:]...)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="三、堆排序"><a href="#三、堆排序" class="headerlink" title="三、堆排序"></a>三、堆排序</h4><p>堆的概念：</p><p>堆（heap）是一种满足特定条件的完全二叉树，具有完全二叉树的所有特征，主要可分为两种类型。</p><ul><li>小顶堆（min heap）：任意节点的值 ≤ 其子节点的值，堆顶（根节点）的元素最小。</li><li>大顶堆（max heap）：任意节点的值 ≥ 其子节点的值，堆顶（根节点）的元素最小。</li></ul><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    largest := i</span><br><span class="line">    left := i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    right := i*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n &amp;&amp; arr[left] &gt; arr[largest] &#123;</span><br><span class="line">        largest = left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> right &lt; n &amp;&amp; arr[right] &gt; arr[largest] &#123;</span><br><span class="line">        largest = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="四、性能测试对比"><a href="#四、性能测试对比" class="headerlink" title="四、性能测试对比"></a>四、性能测试对比</h4><p>在下文中通过生成一个特定长度的随机数数组，对我们自己实现的三种排序算法进行性能测试，并与go标准库的sort进行对比</p><p>长度为<strong>100</strong>随机数数组：</p><ul><li><p>快速排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/quicksort100.png"></p></li><li><p>归并排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/mergesort100.png"></p></li><li><p>堆排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/heapsort100.png"></p></li><li><p>go标准库sort<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/sort100.png"></p></li></ul><p>长度为<strong>1000</strong>随机数数组：</p><ul><li><p>快速排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/quicksort1000.png"></p></li><li><p>归并排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/mergesort1000.png"></p></li><li><p>堆排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/heapsort1000.png"></p></li><li><p>go标准库sort<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/sort1000.png"></p></li></ul><p>长度为<strong>3000</strong>随机数数组：</p><ul><li><p>快速排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/quicksort3000.png"></p></li><li><p>归并排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/mergesort3000.png"></p></li><li><p>堆排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/heapsort3000.png"></p></li><li><p>go标准库sort<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/sort3000.png"></p></li></ul><p>对以上信息进行观测，我们可以看出：</p><ul><li>在数组长度较短的情况下（100左右），堆排序的最好，快速排序和归并排序的速率接近，但堆排序需要申请一块临时内存用于存储待归并的数组，因此有一定的空间开销。</li><li>在数组长度达到1000时，快速排序的速率明显下降，此时归并排序的速率最快</li><li>在数组长度达到3000时仍然是归并排序的性能最高。</li></ul><p><strong>但是！</strong> 在上文中我是用的堆排序函数是<strong>BenchmarkHeapSort1</strong>，证明我还写了其他的堆排序实现方法，这里我给出另一个堆排序函数的区别（在调整堆的heapify函数中）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify2</span><span class="params">(arr []<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用迭代方式替换了递归</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        largest := i</span><br><span class="line">        left := i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        right := i*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; n &amp;&amp; arr[left] &gt; arr[largest] &#123;</span><br><span class="line">            largest = left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right &lt; n &amp;&amp; arr[right] &gt; arr[largest] &#123;</span><br><span class="line">            largest = right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">            arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">            i = largest</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用迭代的堆调整函数后堆排序的性能测试结果如下：<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/mergesort2.png"></p><p>可以看出用迭代方式进行堆调整的堆排序性能更高，我们通过对比递归和迭代的区别来探究性能差异的原因：</p><ul><li>递归：因为每次递归调用都会产生新的函数调用，这意味着需要分配新的栈帧来存储局部变量、参数和其他状态信息。此外，每次函数调用都需要进行参数传递、返回地址的保存以及函数体的执行，这增加了额外的时间开销。</li><li>迭代：迭代通常在一个循环中完成，不需要创建新的函数调用，因此减少了函数调用带来的开销。<br></li></ul><p><strong>最终结论：</strong> 在数组长度较短时（100左右），优先使用快速排序和堆排序，其余情况可以使用归并排序或堆排序</p><p>附：测试用的初始化随机数数组代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    arr = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1000</span>)</span><br><span class="line">    initArray(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initArray</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">        arr[i] = generateRandomInt(<span class="number">0</span>, <span class="built_in">len</span>(arr)-<span class="built_in">len</span>(arr)/<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateRandomInt</span><span class="params">(min, max <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rand.Intn(max-min+<span class="number">1</span>) + min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构预算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解为什么缓冲区可以大幅度提高I/O性能</title>
      <link href="/%E7%90%86%E8%A7%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%AF%E4%BB%A5%E5%A4%A7%E5%B9%85%E5%BA%A6%E6%8F%90%E9%AB%98I-O%E6%80%A7%E8%83%BD/"/>
      <url>/%E7%90%86%E8%A7%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%AF%E4%BB%A5%E5%A4%A7%E5%B9%85%E5%BA%A6%E6%8F%90%E9%AB%98I-O%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="一、缓冲区的基本概念"><a href="#一、缓冲区的基本概念" class="headerlink" title="一、缓冲区的基本概念"></a>一、缓冲区的基本概念</h3><p>缓冲区是在内存中分配的一段空间，用于暂时存储数据。当数据从一个设备传送到另一个设备时，缓冲区可以用来平滑这种传输过程，使得数据的发送和接收更加高效。<br><br></p><h3 id="二、为什么需要缓冲区"><a href="#二、为什么需要缓冲区" class="headerlink" title="二、为什么需要缓冲区"></a>二、为什么需要缓冲区</h3><p>计算机磁盘是由一个个磁道构成，每次进行数据读写的时候，都需要通过磁头寻找到到合适的磁道，才能执行读写数据的操作，而这个过程需要耗费一定的时间，即<strong>寻道时间</strong>。当我们引入缓冲区后，可以将多次小量的数据写入操作合并为一次大量的写入操作，从而大大减少寻道时间和旋转延迟，提高数据的读写效率。<br><br></p><h3 id="三、缓冲区类型"><a href="#三、缓冲区类型" class="headerlink" title="三、缓冲区类型"></a>三、缓冲区类型</h3><ol><li>全缓冲：数据只有在缓冲区满时才会被实际写入或读取。</li><li>行缓冲：在文本输入的情况下，数据在遇到换行符时会被实际写入或读取。</li><li>无缓冲：每次数据写入或读取都会立即执行。<br></li></ol><h3 id="四、自行实现带缓冲的I-O"><a href="#四、自行实现带缓冲的I-O" class="headerlink" title="四、自行实现带缓冲的I&#x2F;O"></a>四、自行实现带缓冲的I&#x2F;O</h3><p>用go代码作为演示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BufferedFileWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    buffer         []<span class="type">byte</span></span><br><span class="line">    bufferEndIndex <span class="type">int</span></span><br><span class="line">    fout           *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(f *os.File, bufferSize <span class="type">int</span>)</span></span> *BufferedFileWriter &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;BufferedFileWriter&#123;</span><br><span class="line">        buffer:         <span class="built_in">make</span>([]<span class="type">byte</span>, bufferSize),</span><br><span class="line">        bufferEndIndex: <span class="number">0</span>,</span><br><span class="line">        fout:           f,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *BufferedFileWriter)</span></span> Write(p []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="built_in">len</span>(w.buffer) &#123;</span><br><span class="line">        w.flush()</span><br><span class="line">        _, _ = w.fout.Write(p)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> w.bufferEndIndex+<span class="built_in">len</span>(p) &gt;= <span class="built_in">len</span>(w.buffer) &#123;</span><br><span class="line">            w.flush()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(w.buffer[w.bufferEndIndex:], p)</span><br><span class="line">        w.bufferEndIndex += <span class="built_in">len</span>(p)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *BufferedFileWriter)</span></span> flush() &#123;</span><br><span class="line">    _, _ = w.fout.Write(w.buffer[<span class="number">0</span>:w.bufferEndIndex])</span><br><span class="line">    w.bufferEndIndex = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *BufferedFileWriter)</span></span> WriteString(s <span class="type">string</span>) &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>与直接写文件和标准库的bufio对比耗时<br>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteDirectly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fout, err := os.OpenFile(outFile1, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        HandleError(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(fout *os.File)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := fout.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(fout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := fout.WriteString(text + <span class="string">&quot;\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带缓冲区写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteWithBuffer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fout, err := os.OpenFile(outFile2, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        HandleError(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(fout *os.File)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := fout.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(fout)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义较大的缓冲区减少写磁盘次数，空间换时间</span></span><br><span class="line">    writer := NewWriter(fout, <span class="number">8</span>*<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">defer</span> writer.flush()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++ &#123;</span><br><span class="line">        writer.WriteString(text + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bufio写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteWithBufio</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fout, err := os.Create(outFile3)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        HandleError(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(fout *os.File)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := fout.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(fout)</span><br><span class="line">    writer := bufio.NewWriter(fout)</span><br><span class="line">    <span class="keyword">defer</span> writer.Flush()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := writer.WriteString(text + <span class="string">&quot;\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBufferIO</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t1 := time.Now()</span><br><span class="line">    WriteDirectly()</span><br><span class="line">    t2 := time.Now()</span><br><span class="line">    WriteWithBuffer()</span><br><span class="line">    t3 := time.Now()</span><br><span class="line">    WriteWithBufio()</span><br><span class="line">    t4 := time.Now()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;直接写文件耗时:%v, 自行实现带缓冲区写文件:%v, 使用go标准库bufio写文件耗时:%v&quot;</span>, t2.Sub(t1), t3.Sub(t2), t4.Sub(t3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/../img/%E7%90%86%E8%A7%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%AF%E4%BB%A5%E5%A4%A7%E5%B9%85%E5%BA%A6%E6%8F%90%E9%AB%98IO%E6%80%A7%E8%83%BD/test_bufferIO.png"><br>可以看出，自行实现带缓冲区写文件比直接写文件要快很多，速度接近于使用go标准库bufio。<br><br></p><h4 id="五、与缓存的区别"><a href="#五、与缓存的区别" class="headerlink" title="五、与缓存的区别"></a>五、与缓存的区别</h4><p>缓存主要用于存储最近或最经常访问的数据，利用硬件的性能优势，加快数据的访问速度，例如redis缓存利用内存速度远远大于磁盘的优势。在计算机底层则有CPU缓存(L1、L2、L3)；内存缓存DRAM Cache；磁盘缓存Disk Cache等，从磁盘到CPU的缓存空间越来越大，性能也越来越好，造价也越来越高</p><p>而缓冲区主要用于减少数据传输和磁盘的读写次数，提高数据的读写效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识实操 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
