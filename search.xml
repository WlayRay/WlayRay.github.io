<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用jmeter压测TCP项目</title>
      <link href="/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/"/>
      <url>/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前置准备"><a href="#一、前置准备" class="headerlink" title="一、前置准备"></a>一、前置准备</h2><h3 id="1-下载jmeter"><a href="#1-下载jmeter" class="headerlink" title="1.下载jmeter"></a>1.下载jmeter</h3><p>首先需要有java环境，安装java环境在这里不做演示</p><p>jmeter官网下载链接：<a href="https://jmeter.apache.org/download_jmeter.cgi" download>Apache JMeter - Download Apache JMeter</a></p><p>下载下面的二进制压缩包<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/downloadjmeter.png"><br><br></p><h3 id="2-中文切换（可选）"><a href="#2-中文切换（可选）" class="headerlink" title="2. 中文切换（可选）"></a>2. 中文切换（可选）</h3><p>在解压后的bin（apache-jmeter-5.6.3\bin）目录里编辑jmeter.properties文件，找到#language&#x3D;en，将其取消注释并改成language&#x3D;zh_CN<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/setChinese.png"></p><h3 id="3-运行jmeter"><a href="#3-运行jmeter" class="headerlink" title="3.运行jmeter"></a>3.运行jmeter</h3><p>在bin目录里找到jmeter.bat文件，双击运行<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/runjmeter.png"><br>稍等一会后会出现jmeter的图形化界面<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/jmeterGUI.png"><br><br></p><h2 id="二、压测步骤"><a href="#二、压测步骤" class="headerlink" title="二、压测步骤"></a>二、压测步骤</h2><h3 id="1-创建线程组"><a href="#1-创建线程组" class="headerlink" title="1.创建线程组"></a>1.创建线程组</h3><p>右键测试计划，选择添加-&gt;线程（用户）-&gt;线程组<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/addThreadGroup.png"></p><p>这里我先创建1500个线程，设置启动延迟为10秒，并选择创建线程直到需要。<br><strong>解释：</strong> 线程数可以理解为并发数，启动延迟（Ramp-Up Period）可以理解为压测开始前的等待时间，当你在 JMeter 的线程组中设置了“Ramp-Up时间”时，JMeter 会在这个时间段内逐渐启动所有线程，而不是一次性启动所有线程。例如，我设置了线程数为 1500，启动延迟为 10 秒，那么 JMeter 将在这 60 秒内依次启动 1500 个线程，有助于测试服务器在逐步增加的负载下的表现。<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/threadGroup.png"></p><h3 id="2-添加TCP取样器"><a href="#2-添加TCP取样器" class="headerlink" title="2.添加TCP取样器"></a>2.添加TCP取样器</h3><p>右键刚刚的线程组，选择添加-&gt;取样器-&gt;TCP取样器<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/tcpSampler.png"></p><p>填入要压测服务的IP、端口等信息<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/samplerInfo.png"><br>注意图中红色方框，因为TCP是流是协议，应用程序需要根据一个特殊的标识来判断是否已经到所有数据，因此需要我们配置”行尾（EOF）字节值”，取值范围为 -128 到 +127，它用于定义 TCP 服务器响应数据的结束标识。当 jmeter 接收到来自服务器的数据时，它会根据这个 EOF 字节值来判断何时停止读取更多的数据。</p><p>比如果说我的请求和响应如下：<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E6%B5%8B%E8%AF%95%E8%AF%B7%E6%B1%82%E6%A0%B7%E4%BE%8B.png"><br>如果服务正常运行则会返回json文本：<br>{“errmsg”:”No such method, failed to process your request!”,”errno”:404,”msgType”:404}<br>表示找不到msgType为100的方法，该文本最后一个字符是是”}”，对应的编码转为10进制是125，因此在行位尾（EOF）字节值中填入125</p><p>如果不填入行尾（EOF）字节值，jmeter会一直等待，直到超时，或者直到服务器返回数据，导致压测失败。</p><p>可以看到即使返回了预期的json也仍然显示失败<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E6%B5%8B%E8%AF%95%E5%A4%B1%E8%B4%A5.png"></p><p>填入行位尾（EOF）字节值后，测试成功：<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F.png"></p><h3 id="3-添加监听器"><a href="#3-添加监听器" class="headerlink" title="3.添加监听器"></a>3.添加监听器</h3><p>右键TCP取样器，选择添加-&gt;监听器，可以添加多个不同功能的监听器<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/addListener.png"></p><p>点击上方的绿色启动按钮进行压测<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E5%90%AF%E5%8A%A8%E5%8E%8B%E6%B5%8B.png"></p><h2 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h2><p>压测的项目地址：<a href="https://github.com/WlayRay/RayBoxServer">https://github.com/WlayRay/RayBoxServer</a></p><p>走数据库的请求压测<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E8%B5%B0%E6%95%B0%E6%8D%AE%E5%BA%9310%E7%A7%92%E7%BC%93%E5%86%B29500%E5%B9%B6%E5%8F%91%E5%8E%8B%E6%B5%8B.png"><br>不走数据库<br><img src="/../img/%E4%BD%BF%E7%94%A8jmeter%E5%8E%8B%E6%B5%8BTCP%E9%A1%B9%E7%9B%AE/%E4%B8%8D%E8%B5%B0%E6%95%B0%E6%8D%AE%E5%BA%9310%E7%A7%92%E7%BC%93%E5%86%B216000%E5%B9%B6%E5%8F%91%E5%8E%8B%E6%B5%8B.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序、归并排序、堆排序对比</title>
      <link href="/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AF%B9%E6%AF%94/"/>
      <url>/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h3 id="在所有排序算法中，平均时间复杂度为O-nlogn-的算法一共有三种：快速排序、归并排序、堆排序。"><a href="#在所有排序算法中，平均时间复杂度为O-nlogn-的算法一共有三种：快速排序、归并排序、堆排序。" class="headerlink" title="在所有排序算法中，平均时间复杂度为O(nlogn)的算法一共有三种：快速排序、归并排序、堆排序。"></a>在所有排序算法中，平均时间复杂度为O(nlogn)的算法一共有三种：快速排序、归并排序、堆排序。</h3><table><thead><tr><th>排序算法</th><th align="center">最好情况时间复杂度</th><th align="center">平均情况时间复杂度</th><th align="center">最坏情况时间复杂度</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td>选择排序</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td>插入排序</td><td align="center">O(n)</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td>冒泡排序</td><td align="center">O(n)</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td>归并排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td>快速排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n²)</td><td align="center">O(log n)</td><td align="center">不稳定</td></tr><tr><td>堆排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td>希尔排序</td><td align="center">O(n)</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td>基数排序</td><td align="center">O(nk)</td><td align="center">O(nk)</td><td align="center">O(nk)</td><td align="center">O(n + d)</td><td align="center">稳定</td></tr></tbody></table><p>注：</p><ul><li><strong>稳定性</strong>：如果两个元素相等，排序后它们的相对顺序不变，则称该排序算法是稳定的。</li><li><strong>希尔排序的时间复杂度</strong>和增量选择有关，如果增量序列是1，2，4，8，16，32，64，128，256，512，1024，则时间复杂度为O(n)。</li><li><strong>基数排序的时间复杂度</strong>为O(nk)，其中k为元素的位数。<br></li></ul><h4 id="一、快速排序"><a href="#一、快速排序" class="headerlink" title="一、快速排序"></a>一、快速排序</h4><p>步骤详解：</p><ol><li>选择基准值<ul><li>选择基准值，一般选择第一个元素作为基准值。</li></ul></li><li>分区操作<ul><li>将数组分成两个部分，左边的元素都小于基准值，右边的元素都大于基准值。</li><li>常见的分区方法是使用两个指针，一个从左向右扫描，另一个从右向左扫描，当左侧的指针找到一个大于基准值的元素时停止，右侧的指针找到一个小于基准值的元素时停止，然后交换这两个元素的位置。</li><li>这个过程一直持续到两个指针相遇，这时将基准值与相遇位置的元素交换，这样基准值就位于正确的位置上。</li></ul></li><li>递归排序<ul><li>对基准值左边的子数组和基准值右边的子数组进行递归排序。</li></ul></li></ol><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">        mid := partition(arr, left, right)</span><br><span class="line">        QuickSort(arr, left, mid<span class="number">-1</span>)</span><br><span class="line">        QuickSort(arr, mid+<span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    pivot, l := arr[right], left<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := left; i &lt; right; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; pivot &#123;</span><br><span class="line">         l++</span><br><span class="line">            arr[l], arr[i] = arr[i], arr[l]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    l++</span><br><span class="line">    arr[l], arr[right] = arr[right], arr[l]</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="二、归并排序"><a href="#二、归并排序" class="headerlink" title="二、归并排序"></a>二、归并排序</h4><p>步骤详解：</p><ol><li>分割：如果数组长度大于1，则将数组分成两个子数组。</li><li>递归排序：递归地对两个子数组进行排序。</li><li>合并：将两个已排序的子数组合并成一个有序数组。</li></ol><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mid := <span class="built_in">len</span>(arr) / <span class="number">2</span></span><br><span class="line">    left := MergeSort(arr[:mid])</span><br><span class="line">    right := MergeSort(arr[mid:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, left[i])</span><br><span class="line">        i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, right[j])</span><br><span class="line">        j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当其中一个数组已经全部被添加到结果数组中，将另一个数组剩下的元素添加进来</span></span><br><span class="line">    result = <span class="built_in">append</span>(result, left[i:]...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, right[j:]...)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="三、堆排序"><a href="#三、堆排序" class="headerlink" title="三、堆排序"></a>三、堆排序</h4><p>堆的概念：</p><p>堆（heap）是一种满足特定条件的完全二叉树，具有完全二叉树的所有特征，主要可分为两种类型。</p><ul><li>小顶堆（min heap）：任意节点的值 ≤ 其子节点的值，堆顶（根节点）的元素最小。</li><li>大顶堆（max heap）：任意节点的值 ≥ 其子节点的值，堆顶（根节点）的元素最小。</li></ul><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    largest := i</span><br><span class="line">    left := i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    right := i*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n &amp;&amp; arr[left] &gt; arr[largest] &#123;</span><br><span class="line">        largest = left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> right &lt; n &amp;&amp; arr[right] &gt; arr[largest] &#123;</span><br><span class="line">        largest = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="四、性能测试对比"><a href="#四、性能测试对比" class="headerlink" title="四、性能测试对比"></a>四、性能测试对比</h4><p>在下文中通过生成一个特定长度的随机数数组，对我们自己实现的三种排序算法进行性能测试，并与go标准库的sort进行对比</p><p>长度为<strong>100</strong>随机数数组：</p><ul><li><p>快速排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/quicksort100.png"></p></li><li><p>归并排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/mergesort100.png"></p></li><li><p>堆排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/heapsort100.png"></p></li><li><p>go标准库sort<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/sort100.png"></p></li></ul><p>长度为<strong>1000</strong>随机数数组：</p><ul><li><p>快速排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/quicksort1000.png"></p></li><li><p>归并排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/mergesort1000.png"></p></li><li><p>堆排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/heapsort1000.png"></p></li><li><p>go标准库sort<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/sort1000.png"></p></li></ul><p>长度为<strong>3000</strong>随机数数组：</p><ul><li><p>快速排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/quicksort3000.png"></p></li><li><p>归并排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/mergesort3000.png"></p></li><li><p>堆排序<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/heapsort3000.png"></p></li><li><p>go标准库sort<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/sort3000.png"></p></li></ul><p>对以上信息进行观测，我们可以看出：</p><ul><li>在数组长度较短的情况下（100左右），堆排序的最好，快速排序和归并排序的速率接近，但堆排序需要申请一块临时内存用于存储待归并的数组，因此有一定的空间开销。</li><li>在数组长度达到1000时，快速排序的速率明显下降，此时归并排序的速率最快</li><li>在数组长度达到3000时仍然是归并排序的性能最高。</li></ul><p><strong>但是！</strong> 在上文中我是用的堆排序函数是<strong>BenchmarkHeapSort1</strong>，证明我还写了其他的堆排序实现方法，这里我给出另一个堆排序函数的区别（在调整堆的heapify函数中）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify2</span><span class="params">(arr []<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用迭代方式替换了递归</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        largest := i</span><br><span class="line">        left := i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        right := i*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; n &amp;&amp; arr[left] &gt; arr[largest] &#123;</span><br><span class="line">            largest = left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right &lt; n &amp;&amp; arr[right] &gt; arr[largest] &#123;</span><br><span class="line">            largest = right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">            arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">            i = largest</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用迭代的堆调整函数后堆排序的性能测试结果如下：<br><img src="/../img/%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/mergesort2.png"></p><p>可以看出用迭代方式进行堆调整的堆排序性能更高，我们通过对比递归和迭代的区别来探究性能差异的原因：</p><ul><li>递归：因为每次递归调用都会产生新的函数调用，这意味着需要分配新的栈帧来存储局部变量、参数和其他状态信息。此外，每次函数调用都需要进行参数传递、返回地址的保存以及函数体的执行，这增加了额外的时间开销。</li><li>迭代：迭代通常在一个循环中完成，不需要创建新的函数调用，因此减少了函数调用带来的开销。<br></li></ul><p><strong>最终结论：</strong> 在数组长度较短时（100左右），优先使用快速排序和堆排序，其余情况可以使用归并排序或堆排序</p><p>附：测试用的初始化随机数数组代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    arr = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1000</span>)</span><br><span class="line">    initArray(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initArray</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">        arr[i] = generateRandomInt(<span class="number">0</span>, <span class="built_in">len</span>(arr)-<span class="built_in">len</span>(arr)/<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateRandomInt</span><span class="params">(min, max <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rand.Intn(max-min+<span class="number">1</span>) + min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>理解为什么缓冲区可以大幅度提高I/O性能</title>
      <link href="/%E7%90%86%E8%A7%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%AF%E4%BB%A5%E5%A4%A7%E5%B9%85%E5%BA%A6%E6%8F%90%E9%AB%98I-O%E6%80%A7%E8%83%BD/"/>
      <url>/%E7%90%86%E8%A7%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%AF%E4%BB%A5%E5%A4%A7%E5%B9%85%E5%BA%A6%E6%8F%90%E9%AB%98I-O%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="一、缓冲区的基本概念"><a href="#一、缓冲区的基本概念" class="headerlink" title="一、缓冲区的基本概念"></a>一、缓冲区的基本概念</h3><p>缓冲区是在内存中分配的一段空间，用于暂时存储数据。当数据从一个设备传送到另一个设备时，缓冲区可以用来平滑这种传输过程，使得数据的发送和接收更加高效。<br><br></p><h3 id="二、为什么需要缓冲区"><a href="#二、为什么需要缓冲区" class="headerlink" title="二、为什么需要缓冲区"></a>二、为什么需要缓冲区</h3><p>计算机磁盘是由一个个磁道构成，每次进行数据读写的时候，都需要通过磁头寻找到到合适的磁道，才能执行读写数据的操作，而这个过程需要耗费一定的时间，即<strong>寻道时间</strong>。当我们引入缓冲区后，可以将多次小量的数据写入操作合并为一次大量的写入操作，从而大大减少寻道时间和旋转延迟，提高数据的读写效率。<br><br></p><h3 id="三、缓冲区类型"><a href="#三、缓冲区类型" class="headerlink" title="三、缓冲区类型"></a>三、缓冲区类型</h3><ol><li>全缓冲：数据只有在缓冲区满时才会被实际写入或读取。</li><li>行缓冲：在文本输入的情况下，数据在遇到换行符时会被实际写入或读取。</li><li>无缓冲：每次数据写入或读取都会立即执行。<br></li></ol><h3 id="四、自行实现带缓冲的I-O"><a href="#四、自行实现带缓冲的I-O" class="headerlink" title="四、自行实现带缓冲的I&#x2F;O"></a>四、自行实现带缓冲的I&#x2F;O</h3><p>用go代码作为演示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BufferedFileWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    buffer         []<span class="type">byte</span></span><br><span class="line">    bufferEndIndex <span class="type">int</span></span><br><span class="line">    fout           *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(f *os.File, bufferSize <span class="type">int</span>)</span></span> *BufferedFileWriter &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;BufferedFileWriter&#123;</span><br><span class="line">        buffer:         <span class="built_in">make</span>([]<span class="type">byte</span>, bufferSize),</span><br><span class="line">        bufferEndIndex: <span class="number">0</span>,</span><br><span class="line">        fout:           f,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *BufferedFileWriter)</span></span> Write(p []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="built_in">len</span>(w.buffer) &#123;</span><br><span class="line">        w.flush()</span><br><span class="line">        _, _ = w.fout.Write(p)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> w.bufferEndIndex+<span class="built_in">len</span>(p) &gt;= <span class="built_in">len</span>(w.buffer) &#123;</span><br><span class="line">            w.flush()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(w.buffer[w.bufferEndIndex:], p)</span><br><span class="line">        w.bufferEndIndex += <span class="built_in">len</span>(p)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *BufferedFileWriter)</span></span> flush() &#123;</span><br><span class="line">    _, _ = w.fout.Write(w.buffer[<span class="number">0</span>:w.bufferEndIndex])</span><br><span class="line">    w.bufferEndIndex = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *BufferedFileWriter)</span></span> WriteString(s <span class="type">string</span>) &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>与直接写文件和标准库的bufio对比耗时<br>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteDirectly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fout, err := os.OpenFile(outFile1, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        HandleError(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(fout *os.File)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := fout.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(fout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := fout.WriteString(text + <span class="string">&quot;\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带缓冲区写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteWithBuffer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fout, err := os.OpenFile(outFile2, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        HandleError(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(fout *os.File)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := fout.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(fout)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义较大的缓冲区减少写磁盘次数，空间换时间</span></span><br><span class="line">    writer := NewWriter(fout, <span class="number">8</span>*<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">defer</span> writer.flush()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++ &#123;</span><br><span class="line">        writer.WriteString(text + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bufio写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteWithBufio</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fout, err := os.Create(outFile3)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        HandleError(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(fout *os.File)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := fout.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(fout)</span><br><span class="line">    writer := bufio.NewWriter(fout)</span><br><span class="line">    <span class="keyword">defer</span> writer.Flush()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := writer.WriteString(text + <span class="string">&quot;\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBufferIO</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t1 := time.Now()</span><br><span class="line">    WriteDirectly()</span><br><span class="line">    t2 := time.Now()</span><br><span class="line">    WriteWithBuffer()</span><br><span class="line">    t3 := time.Now()</span><br><span class="line">    WriteWithBufio()</span><br><span class="line">    t4 := time.Now()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;直接写文件耗时:%v, 自行实现带缓冲区写文件:%v, 使用go标准库bufio写文件耗时:%v&quot;</span>, t2.Sub(t1), t3.Sub(t2), t4.Sub(t3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/../img/%E7%90%86%E8%A7%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%AF%E4%BB%A5%E5%A4%A7%E5%B9%85%E5%BA%A6%E6%8F%90%E9%AB%98IO%E6%80%A7%E8%83%BD/test_bufferIO.png"><br>可以看出，自行实现带缓冲区写文件比直接写文件要快很多，速度接近于使用go标准库bufio。<br><br></p><h4 id="五、与缓存的区别"><a href="#五、与缓存的区别" class="headerlink" title="五、与缓存的区别"></a>五、与缓存的区别</h4><p>缓存主要用于存储最近或最经常访问的数据，利用硬件的性能优势，加快数据的访问速度，例如redis缓存利用内存速度远远大于磁盘的优势。在计算机底层则有CPU缓存(L1、L2、L3)；内存缓存DRAM Cache；磁盘缓存Disk Cache等，从磁盘到CPU的缓存空间越来越大，性能也越来越好，造价也越来越高</p><p>而缓冲区主要用于减少数据传输和磁盘的读写次数，提高数据的读写效率。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
